
---
alwaysApply: true
---

# Database Interaction Rules - QUERY LAYER ENFORCEMENT

All database interactions in this project MUST go through helper functions in the `db/queries` directory. **DIRECT DATABASE OPERATIONS ARE STRICTLY FORBIDDEN** in components, server actions, or any other application code.

## CRITICAL RULE: DB/QUERIES DIRECTORY ONLY

**ABSOLUTELY NO DIRECT DATABASE OPERATIONS ARE ALLOWED OUTSIDE OF `db/queries/`.**

- ✅ **ONLY USE** query helper functions from `@/db/queries/`
- ❌ **NEVER IMPORT** `db` directly in components, server actions, or pages
- ❌ **NEVER WRITE** direct Drizzle queries outside of the queries directory
- ❌ **NEVER ACCESS** database tables directly from application code

## Database Setup

The centralized database configuration should ONLY be used within query helper functions:

```typescript
// ✅ CORRECT - Only in db/queries files
import { db } from "@/db"
import { decksTable, cardsTable } from "@/db/schema"
```

```typescript
// ❌ INCORRECT - Never in components/actions
import { db } from "@/db" // FORBIDDEN outside db/queries
```

## Schema Reference

### Decks Table
- `id`: Auto-generated primary key (integer)
- `title`: Required varchar(255)
- `description`: Optional text
- `userId`: Required varchar(255) - Clerk user ID
- `createdAt`: Auto-generated timestamp
- `updatedAt`: Auto-generated timestamp

### Cards Table
- `id`: Auto-generated primary key (integer)
- `deckId`: Required foreign key to decksTable.id (cascade delete)
- `front`: Required text
- `back`: Required text
- `createdAt`: Auto-generated timestamp
- `updatedAt`: Auto-generated timestamp

## Required Directory Structure

Organize ALL database operations in the queries directory:

```
src/
├── db/
│   ├── index.ts          # Database connection (import only in queries/)
│   ├── schema.ts         # Table schemas (import only in queries/)
│   └── queries/          # ALL database operations MUST be here
│       ├── index.ts      # Export all queries
│       ├── deck-queries.ts
│       ├── card-queries.ts
│       └── user-queries.ts
├── app/
│   ├── actions/          # Server Actions (use queries only)
│   └── [pages]/          # Pages (use queries only)
└── components/           # Components (never access database)
```

## Query Helper Patterns

### Create Operations

#### Deck Queries (db/queries/deck-queries.ts)
```typescript
import { db } from "@/db"
import { decksTable } from "@/db/schema"
import { eq, and } from "drizzle-orm"
import type { InferSelectModel, InferInsertModel } from "drizzle-orm"

export type Deck = InferSelectModel<typeof decksTable>
export type NewDeck = InferInsertModel<typeof decksTable>

export async function createDeck(title: string, description: string | undefined, userId: string) {
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      title,
      description,
      userId,
    })
    .returning()
  
  return newDeck
}

export async function getUserDecks(userId: string) {
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))
    .orderBy(decksTable.createdAt)
  
  return decks
}

export async function getDeckById(deckId: number, userId: string) {
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
  
  return deck || null
}

export async function updateDeck(
  deckId: number, 
  userId: string, 
  updates: { title?: string; description?: string }
) {
  const [updatedDeck] = await db
    .update(decksTable)
    .set({
      ...updates,
      updatedAt: new Date(),
    })
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning()
  
  return updatedDeck
}

export async function deleteDeck(deckId: number, userId: string) {
  const [deletedDeck] = await db
    .delete(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning()
  
  return deletedDeck
}
```

#### Card Queries (db/queries/card-queries.ts)
```typescript
import { db } from "@/db"
import { cardsTable, decksTable } from "@/db/schema"
import { eq, and, ilike, or } from "drizzle-orm"
import type { InferSelectModel, InferInsertModel } from "drizzle-orm"

export type Card = InferSelectModel<typeof cardsTable>
export type NewCard = InferInsertModel<typeof cardsTable>

export async function createCard(deckId: number, front: string, back: string, userId: string) {
  // Verify deck ownership first
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
  
  if (!deck) {
    throw new Error("Deck not found or access denied")
  }

  const [newCard] = await db
    .insert(cardsTable)
    .values({
      deckId,
      front,
      back,
    })
    .returning()
  
  return newCard
}

export async function getDeckCards(deckId: number, userId: string) {
  // Verify deck ownership
  const cards = await db
    .select({
      id: cardsTable.id,
      front: cardsTable.front,
      back: cardsTable.back,
      createdAt: cardsTable.createdAt,
      updatedAt: cardsTable.updatedAt,
    })
    .from(cardsTable)
    .innerJoin(decksTable, eq(cardsTable.deckId, decksTable.id))
    .where(and(
      eq(decksTable.userId, userId),
      eq(cardsTable.deckId, deckId)
    ))
    .orderBy(cardsTable.createdAt)
  
  return cards
}

export async function updateCard(
  cardId: number,
  userId: string,
  updates: { front?: string; back?: string }
) {
  const [updatedCard] = await db
    .update(cardsTable)
    .set({
      ...updates,
      updatedAt: new Date(),
    })
    .from(cardsTable)
    .innerJoin(decksTable, eq(cardsTable.deckId, decksTable.id))
    .where(and(
      eq(cardsTable.id, cardId),
      eq(decksTable.userId, userId)
    ))
    .returning()
  
  return updatedCard
}

export async function deleteCard(cardId: number, userId: string) {
  const [deletedCard] = await db
    .delete(cardsTable)
    .from(cardsTable)
    .innerJoin(decksTable, eq(cardsTable.deckId, decksTable.id))
    .where(and(
      eq(cardsTable.id, cardId),
      eq(decksTable.userId, userId)
    ))
    .returning()
  
  return deletedCard
}

export async function searchCardsInDeck(deckId: number, userId: string, query: string) {
  const cards = await db
    .select({
      id: cardsTable.id,
      front: cardsTable.front,
      back: cardsTable.back,
      createdAt: cardsTable.createdAt,
    })
    .from(cardsTable)
    .innerJoin(decksTable, eq(cardsTable.deckId, decksTable.id))
    .where(and(
      eq(decksTable.userId, userId),
      eq(cardsTable.deckId, deckId),
      or(
        ilike(cardsTable.front, `%${query}%`),
        ilike(cardsTable.back, `%${query}%`)
      )
    ))
  
  return cards
}
```

#### Query Index (db/queries/index.ts)
```typescript
// Export all query functions
export * from "./deck-queries"
export * from "./card-queries"

// Type exports
export type { Deck, NewDeck } from "./deck-queries"
export type { Card, NewCard } from "./card-queries"
```

## Server Action Usage Pattern

Server Actions MUST only use query helper functions, never direct database operations:

```typescript
// ✅ CORRECT - Server Action using query helpers
"use server"

import { auth } from "@clerk/nextjs/server"
import { createDeck, getUserDecks } from "@/db/queries"
import { createDeckSchema, type CreateDeckInput } from "@/lib/validations"
import { revalidatePath } from "next/cache"

export async function createDeckAction(data: CreateDeckInput) {
  const { userId } = await auth()
  
  if (!userId) {
    throw new Error("Unauthorized")
  }
  
  const validatedData = createDeckSchema.parse(data)
  
  // Use query helper function
  const newDeck = await createDeck(
    validatedData.title,
    validatedData.description,
    userId
  )
  
  revalidatePath("/decks")
  return newDeck
}

export async function getDecksAction() {
  const { userId } = await auth()
  
  if (!userId) {
    throw new Error("Unauthorized")
  }
  
  // Use query helper function
  return await getUserDecks(userId)
}
```

```typescript
// ❌ INCORRECT - Direct database operations in Server Action
"use server"

import { db } from "@/db" // FORBIDDEN
import { decksTable } from "@/db/schema" // FORBIDDEN

export async function createDeckAction(data: CreateDeckInput) {
  // NEVER do direct database operations here
  const [newDeck] = await db.insert(decksTable).values(...) // FORBIDDEN
}
```

## Server Component Usage Pattern

Server Components MUST only use query helper functions:

```typescript
// ✅ CORRECT - Server Component using query helpers
import { auth } from "@clerk/nextjs/server"
import { redirect } from "next/navigation"
import { getUserDecks } from "@/db/queries"

export default async function DecksPage() {
  const { userId } = await auth()
  
  if (!userId) {
    redirect("/")
  }
  
  // Use query helper function
  const decks = await getUserDecks(userId)
  
  return <DecksView decks={decks} />
}
```

```typescript
// ❌ INCORRECT - Direct database operations in Server Component
import { db } from "@/db" // FORBIDDEN
import { decksTable } from "@/db/schema" // FORBIDDEN

export default async function DecksPage() {
  // NEVER do direct database operations here
  const decks = await db.select().from(decksTable)... // FORBIDDEN
}
```

## Advanced Query Patterns

### Complex Queries with Joins
```typescript
// db/queries/analytics-queries.ts
import { db } from "@/db"
import { decksTable, cardsTable } from "@/db/schema"
import { eq, count } from "drizzle-orm"

export async function getDeckStats(userId: string) {
  const stats = await db
    .select({
      deckId: decksTable.id,
      title: decksTable.title,
      cardCount: count(cardsTable.id),
    })
    .from(decksTable)
    .leftJoin(cardsTable, eq(decksTable.id, cardsTable.deckId))
    .where(eq(decksTable.userId, userId))
    .groupBy(decksTable.id, decksTable.title)
  
  return stats
}
```

### Transaction Patterns
```typescript
// db/queries/bulk-operations.ts
import { db } from "@/db"
import { cardsTable, decksTable } from "@/db/schema"
import { eq, and } from "drizzle-orm"

export async function createMultipleCards(
  deckId: number, 
  userId: string,
  cards: Array<{ front: string; back: string }>
) {
  return await db.transaction(async (tx) => {
    // Verify deck ownership first
    const [deck] = await tx
      .select()
      .from(decksTable)
      .where(and(
        eq(decksTable.id, deckId),
        eq(decksTable.userId, userId)
      ))
    
    if (!deck) {
      throw new Error("Deck not found or access denied")
    }
    
    // Insert all cards
    const newCards = await tx
      .insert(cardsTable)
      .values(cards.map(card => ({ ...card, deckId })))
      .returning()
    
    return newCards
  })
}
```

## Security Rules - ENFORCED IN QUERIES

### Always Verify User Ownership
ALL query functions MUST verify user ownership when applicable:

```typescript
// ✅ CORRECT - Ownership verification in query function
export async function updateDeck(deckId: number, userId: string, updates: object) {
  const [updatedDeck] = await db
    .update(decksTable)
    .set(updates)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId) // CRITICAL: verify ownership
    ))
    .returning()
  
  if (!updatedDeck) {
    throw new Error("Deck not found or access denied")
  }
  
  return updatedDeck
}
```

### Error Handling in Queries
```typescript
export async function safeGetDeck(deckId: number, userId: string) {
  try {
    const [deck] = await db
      .select()
      .from(decksTable)
      .where(and(
        eq(decksTable.id, deckId),
        eq(decksTable.userId, userId)
      ))
    
    if (!deck) {
      throw new Error("Deck not found")
    }
    
    return deck
  } catch (error) {
    console.error("Database error:", error)
    throw new Error("Failed to fetch deck")
  }
}
```

## Forbidden Patterns - STRICTLY ENFORCED

❌ **NEVER do these:**
- Import `db` directly in components, server actions, or pages
- Import schema tables outside of `db/queries/` directory
- Write Drizzle queries outside of query helper functions
- Perform database operations without going through query helpers
- Create database connections outside of the centralized configuration

✅ **ALWAYS do these:**
- Use query helper functions from `@/db/queries` for ALL database operations
- Organize queries by domain (decks, cards, users, etc.)
- Include proper TypeScript types in query functions
- Verify user ownership within query functions
- Handle errors gracefully in query functions
- Export all queries through the index file

## Import Patterns

### Correct Import Usage
```typescript
// ✅ In Server Actions or Server Components
import { getUserDecks, createDeck, updateDeck } from "@/db/queries"
import type { Deck, NewDeck } from "@/db/queries"

// ✅ Only in db/queries files
import { db } from "@/db"
import { decksTable } from "@/db/schema"
```

### Forbidden Import Usage
```typescript
// ❌ NEVER in components/actions/pages
import { db } from "@/db" // FORBIDDEN
import { decksTable } from "@/db/schema" // FORBIDDEN
import { eq } from "drizzle-orm" // FORBIDDEN outside queries
```

## ENFORCEMENT

This rule is **ABSOLUTELY NON-NEGOTIABLE**. Any code that violates these guidelines by performing direct database operations outside of the `db/queries` directory MUST be refactored immediately. The query layer provides:

1. **Centralized Data Access**: All database logic in one place
2. **Security**: Consistent ownership verification
3. **Maintainability**: Easy to modify database operations
4. **Type Safety**: Proper TypeScript types for all operations
5. **Testing**: Easy to mock and test database operations

**NO EXCEPTIONS** - All database interactions must go through query helper functions. 